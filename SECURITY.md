# Security Documentation

This document outlines the security controls and measures implemented in the Moodle Rip-off LMS.

## Security Controls

### 1. Password Security

#### User Passwords
- **Hashing Algorithm:** Argon2 (via `django.contrib.auth.hashers.Argon2PasswordHasher`)
- **Fallback Hashers:** PBKDF2, PBKDF2SHA1, BCryptSHA256
- **Password Validation:**
  - User attribute similarity check
  - Minimum length requirement
  - Common password check
  - Numeric-only password prevention
- **Salt:** Automatically generated by Django's password hasher
- **Storage:** Hashed passwords stored in `core_user` table

#### File Share Passwords
- **Hashing Algorithm:** Django `make_password()` with Argon2
- **Salt:** Random 32-character hex string generated via `secrets.token_hex(16)`
- **Storage:** `FileShare.hashed_password` and `FileShare.password_salt` fields
- **Verification:** Uses Django's `check_password()` function
- **Minimum Length:** 6 characters enforced at form validation

### 2. VirusTotal Integration

#### File Scanning
- **API:** VirusTotal API v3
- **Scan Trigger:** Every uploaded file is scanned before storage
- **Verdict Logic:** File rejected if ANY engine flags it as malicious (>=1 malicious engine)
- **Compression:** Files >5MB are compressed (ZIP) before scanning to respect API limits
- **Timeout:** 300-second timeout for scan results with 10-second polling interval
- **Fail-Closed Policy:** If VirusTotal is unavailable, uploads are rejected

#### Stored Information
- `virustotal_report_id`: Analysis ID from VirusTotal
- `virustotal_scan_date`: Timestamp of scan
- `is_malicious`: Boolean flag (True if malicious)
- `virustotal_summary`: JSON with engine statistics (malicious, suspicious, harmless, undetected)

### 3. File Validation

#### Size Limits
- **Maximum File Size:** 200 MB (configurable via `MAX_FILE_SIZE` setting)
- **Large File Threshold:** 5 MB (configurable via `LARGE_FILE_THRESHOLD`)
- **Enforcement:** Server-side validation before processing

#### Content-Type Validation
- **MIME Detection:** Uses `python-magic` library for accurate MIME type detection
- **Extension Matching:** Validates that file extension matches actual content type
- **Supported Types:** Common document, image, audio, video, archive, and code file types
- **Lenient Mode:** Text files have relaxed validation; unknown extensions are allowed

#### Filename Sanitization
- **Path Traversal Prevention:** `os.path.basename()` strips path components
- **Character Filtering:** Only alphanumeric, dots, hyphens, and underscores allowed
- **Space Handling:** Spaces converted to underscores
- **Length Limit:** Filename limited to 200 characters (excluding extension)
- **Storage:** Both original and sanitized names stored

### 4. Access Control

#### Role-Based Permissions
Three role levels with hierarchical permissions:
1. **Student** (lowest privilege)
   - Upload files
   - View files in enrolled courses
   - Download accessible files
   - Cannot delete or share files

2. **Teacher** (medium privilege)
   - All student permissions
   - Create file shares
   - Delete files in owned courses
   - Edit course materials

3. **Administrator** (highest privilege)
   - Full system access
   - Manage all files regardless of ownership
   - Django admin panel access
   - User and role management

#### Permission Checks
- **View Permission:** Checked before displaying file details
- **Download Permission:** Verified before streaming file bytes
- **Edit Permission:** Required for metadata changes
- **Delete Permission:** Enforced before file deletion
- **Share Creation:** Requires edit permission on file

#### Share-Based Access
- **Permission Levels:** Public, Student, Teacher, Administrator
- **Hierarchy:** Access granted if user's role >= required level
- **Password Protection:** Optional additional layer via share password
- **Expiration:** Time-based access control via `expiration_date`
- **Session Tracking:** Password verification stored in session

### 5. CSRF Protection

#### Implementation
- Django's built-in CSRF middleware enabled
- CSRF token required for all state-changing operations (POST, PUT, DELETE)
- `@csrf_protect` decorator on sensitive views
- CSRF token embedded in all forms via `{% csrf_token %}`

#### Cookie Settings
- Default Django CSRF cookie configuration
- SameSite attribute enforced
- Secure flag should be enabled in production (HTTPS)

### 6. SQL Injection Protection

#### Django ORM
- All database queries use Django ORM
- Parameterized queries automatically generated
- No raw SQL queries in codebase
- QuerySet API prevents injection attacks

#### User Input Handling
- All form inputs validated through Django forms
- Type conversion and sanitization automatic
- Database constraints enforce data integrity

### 7. XSS Prevention

#### Template Auto-Escaping
- Django templates auto-escape all variables by default
- HTML entities converted automatically
- Manual escaping with `|safe` filter avoided except when necessary

#### Content Security Policy
- Recommendation: Implement CSP headers in production
- Currently relies on Django's built-in XSS protection

### 8. Data Integrity

#### File Checksums
- **Algorithm:** SHA-256
- **Calculation:** Performed on original file bytes before storage
- **Storage:** 64-character hex string in `checksum_hash` field
- **Indexing:** Database index on checksum for duplicate detection
- **Verification:** Can be used to verify file integrity

#### Database Integrity
- Foreign key constraints enforced
- Unique constraints on critical fields (UUIDs, course codes)
- NOT NULL constraints on required fields
- Cascade deletes configured appropriately

### 9. Secure File Storage

#### BinaryField Storage
- Files stored as BLOBs in SQLite database
- No filesystem access required
- Prevents directory traversal attacks
- Files isolated within database security perimeter

#### Download Security
- Files streamed through Django views (not direct file system links)
- Permission checks before every download
- Content-Disposition header set to "attachment" (prevents inline execution)
- Content-Type set to "application/octet-stream" (no automatic handling)

### 10. Session Security

#### Configuration
- Django's session framework with database backend
- Secure session cookie (HTTPS recommended in production)
- HttpOnly flag on session cookies
- Session timeout configurable

#### Share Password Sessions
- Share password verification stored per-share in session
- Session key format: `share_password_<uuid>`
- Value: `'verified'` after successful password entry

### 11. Rate Limiting

#### VirusTotal API
- Respects API rate limits (free tier: 4 requests/minute)
- Timeout handling prevents infinite waits
- Graceful error handling with user-friendly messages

#### Recommendation
- Implement application-level rate limiting in production
- Use Django middleware or tools like `django-ratelimit`
- Limit file uploads per user/IP
- Limit share creation per user

### 12. Error Handling

#### Information Disclosure Prevention
- Generic error messages shown to users
- Detailed errors logged server-side only
- `DEBUG=False` in production hides stack traces
- Custom error pages (404, 500) recommended

#### VirusTotal Errors
- API failures result in upload rejection (fail-closed)
- User-friendly error messages
- Technical details logged for debugging

### 13. Headers and Hardening

#### Security Headers (Recommended for Production)
- **X-Content-Type-Options:** `nosniff`
- **X-Frame-Options:** `DENY` or `SAMEORIGIN`
- **X-XSS-Protection:** `1; mode=block`
- **Strict-Transport-Security:** `max-age=31536000; includeSubDomains`
- **Content-Security-Policy:** Configure based on application needs

#### Django Security Settings
```python
SECURE_BROWSER_XSS_FILTER = True
SECURE_CONTENT_TYPE_NOSNIFF = True
X_FRAME_OPTIONS = 'DENY'
```

## Security Best Practices

### For Administrators

1. **Keep SECRET_KEY Secret**
   - Never commit to version control
   - Use environment variables
   - Rotate periodically

2. **Use HTTPS in Production**
   - Set `SECURE_SSL_REDIRECT = True`
   - Enable `SECURE_HSTS_SECONDS`
   - Use valid SSL certificates

3. **Regular Updates**
   - Keep Django updated
   - Update all dependencies regularly
   - Monitor security advisories

4. **Database Backups**
   - Regular automated backups
   - Test restoration procedures
   - Secure backup storage

5. **Logging and Monitoring**
   - Enable Django logging
   - Monitor for suspicious activity
   - Alert on failed login attempts

6. **VirusTotal API Key**
   - Protect API key as sensitive credential
   - Use environment variables only
   - Monitor API usage and quotas

### For Developers

1. **Input Validation**
   - Always use Django forms
   - Validate on server-side
   - Never trust client input

2. **Permission Checks**
   - Check permissions for every action
   - Use decorators and services consistently
   - Test permission boundaries

3. **Avoid Raw SQL**
   - Use Django ORM exclusively
   - Parameterize any necessary raw queries
   - Review queries for injection risks

4. **Secure Coding**
   - Follow Django security guidelines
   - Code review for security issues
   - Use static analysis tools

## Known Limitations

1. **File Size Limits**
   - Files >200MB rejected (configurable)
   - VirusTotal free tier limits: 32MB per file, 4 requests/minute
   - Large files may timeout during scanning

2. **SQLite Limitations**
   - Not ideal for high-concurrency scenarios
   - Consider PostgreSQL/MySQL for production
   - BLOB storage may impact performance with many large files

3. **No Built-in Rate Limiting**
   - Recommend implementing application-level rate limiting
   - No protection against automated upload abuse

4. **Public Shares**
   - Public permission level allows unauthenticated access
   - Consider disabling if not needed
   - Monitor share usage

## Reporting Security Issues

If you discover a security vulnerability:

1. **Do not** create a public issue
2. Contact the maintainers directly
3. Provide detailed description and reproduction steps
4. Allow time for fixes before disclosure

## Security Checklist for Production

- [ ] Set `DEBUG = False`
- [ ] Change `SECRET_KEY` to a strong random value
- [ ] Configure `ALLOWED_HOSTS`
- [ ] Enable HTTPS
- [ ] Set security headers
- [ ] Configure HSTS
- [ ] Implement rate limiting
- [ ] Set up logging and monitoring
- [ ] Configure database backups
- [ ] Use production-grade database (PostgreSQL/MySQL)
- [ ] Secure VirusTotal API key
- [ ] Review file size limits
- [ ] Test permission matrix
- [ ] Configure CSP headers
- [ ] Set up firewall rules
- [ ] Regular security audits

## References

- [Django Security](https://docs.djangoproject.com/en/5.0/topics/security/)
- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [VirusTotal API Documentation](https://developers.virustotal.com/reference/overview)
- [Argon2 Password Hashing](https://github.com/P-H-C/phc-winner-argon2)
